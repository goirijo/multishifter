import glob
import json
import numpy as np
import pandas as pd
import os.path
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit
import argparse

def _generate_parser():
    parser = argparse.ArgumentParser(
                    formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument(
        "--name",
        help="The name field in the settings file used to generate shifted structures.",
        type=str,
        required=True)
    parser.add_argument(
        "--full-record",
        help="Reads the records.json file in the appropriate shift directory, and augments it with all energies."
        "Argument determines method to read DFT energy values.",
        type=str,
        # choices=["mush","oszicar"],
        choices=["oszicar", "mush"],
        required=False)

    # argcomplete.autocomplete(parser)
    return parser

def mush_read(path):
    return np.loadtxt(os.path.join(path,"energy.mush"))

def oszicar_energy_read(path):
    target=os.path.join(path,"OSZICAR")
    with open(target,'rb') as fh:
        for line in fh:
            pass
        last=line
    return last.split()[4]

def append_values(record,method):
    """Given the json record of all the shifts, collect
    the energy of each possible value using the provided method
    (takes path as argument) and fill in a new column
    with the desired values

    Parameters
    ----------
    record : json dropped by multishift in shift directory
    method : function that returns the energy of a calculation

    Returns
    -------
    record with an extra column

    """
    paths=record["path"]
    energies=[float(method(p)) for p in paths]
    record["energy"]=np.array(energies)-min(energies)
    return record

def evaluate_uber(x,e,g,l):
    """Given the parameters for UBER and the cleavage value
    x, return the predicted energy.

    Parameters
    ----------
    x : float, cleavage value (zero at minimum)
    e : float, energy at infinite separation
    g : float, surface energy
    l : float

    Returns
    -------
    float

    """
    return e+2*g*(1-(1+x/l)*np.exp(-x/l))

def formatted_write(data,target):
    """Write a pandas DataFrame to a file in the correct
    format multishift wants

    Parameters
    ----------
    data : pandas df
    target : path

    Returns
    -------
    void

    """
    with open(target,'w') as outfile:
        json.dump({key : data[key].tolist() for key in data}, outfile)
    return

def debug():
    parser = _generate_parser()
    args=parser.parse_args()

    name=args.name
    target="energy.mush"

    record=pd.read_json(os.path.join(name+".shift","record.json"))
    record=append_values(record,oszicar_energy_read)

    uber=record.loc[(record["a"]==0) & (record["b"]==0)]
    x=uber["cleavage"]
    y=uber["energy"]
    y=y-min(y)
    popt,pcov=curve_fit(evaluate_uber,x,y)
    # print popt
    xfit=np.arange(min(x),max(x),0.001)
    # plt.plot(xfit,evaluate_uber(xfit,*popt))
    # plt.scatter(x,y)
    # plt.show()

    # x=np.arange(-4,4,0.1)
    # y=[evaluate_uber(val,0,-19,0.5,0.5) for val in x]
    # plt.scatter(x,y)
    # plt.show()

    # record.to_json(name+".values.json",orient='records')
    # print record
    # print json.dumps(json.loads(record.to_json(orient='table')),indent=4)
    with open("full_record.json",'w') as outfile:
        json.dump({key : record[key].tolist() for key in record}, outfile)

    reduced=record.loc[record["cleavage"]==0.0]
    with open("no_cleave.json",'w') as outfile:
        json.dump({key : reduced[key].tolist() for key in reduced}, outfile)

def main():
    parser = _generate_parser()
    args=parser.parse_args()

    name=args.name

    if args.full_record is not None:
        method_dict={"oszicar":oszicar_energy_read, "mush" : mush_read}

        record=pd.read_json(os.path.join(name+".shift","record.json"))
        full_record=append_values(record,method_dict[args.full_record])
        formatted_write(full_record,os.path.join(name+".shift","full_record.json"))

        full_record=pd.read_json(os.path.join(name+".shift","full_record.json"))
        full_record=full_record.set_index(["a","b","energy"])
        full_record=full_record.sort_index(level=["a","b","energy"])
        min_record=full_record.reset_index(level="energy").groupby(level=["a","b"]).first()

        formatted_write(min_record,"./test.json")

    else:
        print("Nothing to do!")

if __name__=="__main__":
    main()
